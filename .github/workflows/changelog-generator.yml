name: Auto-Generate Changelog

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

jobs:
  generate-changelog:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Generate Changelog
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'PYTHON_SCRIPT'
          import subprocess
          import re
          from datetime import datetime
          from collections import defaultdict

          def get_latest_tag():
              """Get the latest git tag"""
              try:
                  result = subprocess.run(
                      ['git', 'describe', '--tags', '--abbrev=0'],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  return result.stdout.strip()
              except:
                  return None

          def get_previous_tag(current_tag):
              """Get the tag before current_tag"""
              try:
                  result = subprocess.run(
                      ['git', 'tag', '--sort=-version:refname'],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  tags = result.stdout.strip().split('\n')
                  current_index = tags.index(current_tag)
                  if current_index + 1 < len(tags):
                      return tags[current_index + 1]
              except:
                  pass
              return None

          def get_commits_between(from_ref, to_ref):
              """Get commits between two refs"""
              if from_ref:
                  cmd = ['git', 'log', f'{from_ref}..{to_ref}', '--pretty=format:%H|%s|%an|%ad', '--date=short']
              else:
                  cmd = ['git', 'log', to_ref, '--pretty=format:%H|%s|%an|%ad', '--date=short']
              
              result = subprocess.run(cmd, capture_output=True, text=True, check=True)
              commits = []
              for line in result.stdout.strip().split('\n'):
                  if line:
                      hash, subject, author, date = line.split('|', 3)
                      commits.append({
                          'hash': hash[:7],
                          'subject': subject,
                          'author': author,
                          'date': date
                      })
              return commits

          def categorize_commits(commits):
              """Categorize commits by conventional commit type"""
              categories = defaultdict(list)
              
              for commit in commits:
                  subject = commit['subject']
                  
                  # Parse conventional commit format
                  match = re.match(r'^(\w+)(\(.+\))?!?:\s*(.+)$', subject)
                  if match:
                      type_name = match.group(1).lower()
                      scope = match.group(2)
                      description = match.group(3)
                      
                      # Map types to categories
                      if type_name in ['feat', 'feature']:
                          categories['Features'].append({**commit, 'description': description})
                      elif type_name == 'fix':
                          categories['Bug Fixes'].append({**commit, 'description': description})
                      elif type_name in ['docs', 'doc']:
                          categories['Documentation'].append({**commit, 'description': description})
                      elif type_name in ['style', 'refactor', 'perf']:
                          categories['Improvements'].append({**commit, 'description': description})
                      elif type_name in ['test', 'tests']:
                          categories['Tests'].append({**commit, 'description': description})
                      elif type_name in ['chore', 'ci', 'build']:
                          categories['Maintenance'].append({**commit, 'description': description})
                      else:
                          categories['Other'].append({**commit, 'description': description})
                  else:
                      # Non-conventional commit
                      categories['Other'].append({**commit, 'description': subject})
              
              return categories

          def generate_changelog_content(tag, date, categories):
              """Generate changelog markdown for a version"""
              lines = [f"## [{tag}] - {date}\n"]
              
              # Order of categories
              category_order = ['Features', 'Bug Fixes', 'Documentation', 'Improvements', 'Tests', 'Maintenance', 'Other']
              
              for category in category_order:
                  if category in categories and categories[category]:
                      lines.append(f"\n### {category}\n")
                      for commit in categories[category]:
                          desc = commit.get('description', commit['subject'])
                          lines.append(f"- {desc} ([{commit['hash']}](https://github.com/LuisSambrano/antigravity-skills/commit/{commit['hash']}))")
              
              lines.append("\n")
              return '\n'.join(lines)

          # Main execution
          print("ðŸ” Detecting latest tag...")
          latest_tag = get_latest_tag()

          if not latest_tag:
              print("âš ï¸ No tags found. Creating initial CHANGELOG.md")
              with open('CHANGELOG.md', 'w') as f:
                  f.write("# Changelog\n\n")
                  f.write("All notable changes to this project will be documented in this file.\n\n")
                  f.write("The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\n")
                  f.write("and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n")
              print("âœ… Created initial CHANGELOG.md")
              exit(0)

          print(f"ðŸ“Œ Latest tag: {latest_tag}")

          previous_tag = get_previous_tag(latest_tag)
          if previous_tag:
              print(f"ðŸ“Œ Previous tag: {previous_tag}")
          else:
              print("ðŸ“Œ No previous tag found (first release)")

          # Get commits
          print("ðŸ“ Fetching commits...")
          commits = get_commits_between(previous_tag, latest_tag)
          print(f"   Found {len(commits)} commits")

          if not commits:
              print("âš ï¸ No commits found between tags")
              exit(0)

          # Categorize commits
          categories = categorize_commits(commits)

          # Generate changelog entry
          today = datetime.now().strftime('%Y-%m-%d')
          new_entry = generate_changelog_content(latest_tag, today, categories)

          # Read existing changelog or create header
          try:
              with open('CHANGELOG.md', 'r') as f:
                  existing_content = f.read()
          except FileNotFoundError:
              existing_content = "# Changelog\n\n"
              existing_content += "All notable changes to this project will be documented in this file.\n\n"
              existing_content += "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\n"
              existing_content += "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n"

          # Check if this version already exists
          if f"## [{latest_tag}]" in existing_content:
              print(f"âš ï¸ Version {latest_tag} already exists in CHANGELOG.md")
              exit(0)

          # Insert new entry after header
          header_end = existing_content.find('\n\n## ')
          if header_end == -1:
              # No previous entries
              new_content = existing_content + new_entry
          else:
              # Insert before first entry
              new_content = existing_content[:header_end + 2] + new_entry + existing_content[header_end + 2:]

          # Write updated changelog
          with open('CHANGELOG.md', 'w') as f:
              f.write(new_content)

          print(f"âœ… Updated CHANGELOG.md with version {latest_tag}")
          print(f"\nðŸ“Š Summary:")
          for category, items in categories.items():
              if items:
                  print(f"   - {category}: {len(items)}")
          PYTHON_SCRIPT

      - name: Commit and push CHANGELOG
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet CHANGELOG.md; then
            echo "No changes to CHANGELOG.md"
          else
            git add CHANGELOG.md
            git commit -m "docs: update CHANGELOG for $(git describe --tags --abbrev=0) [skip ci]"
            git push
            echo "âœ… CHANGELOG.md updated and pushed"
          fi

      - name: Create summary
        run: |
          echo "## ðŸ“ Changelog Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: $(git describe --tags --abbrev=0)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The CHANGELOG.md has been automatically updated." >> $GITHUB_STEP_SUMMARY
